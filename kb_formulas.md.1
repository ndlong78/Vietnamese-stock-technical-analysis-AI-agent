CÔNG THỨC & TÍNH TOÁN (TOÀN DIỆN)
Lưu ý cho AI Agent:
Đây là tài liệu chứa công thức toán học và code Python thực thi.
Khi xử lý dữ liệu chuỗi thời gian (OHLCV), BẮT BUỘC dùng Class VNStockAnalyzer (sử dụng pandas).
Khi tính toán quản lý vốn/lợi nhuận, sử dụng các hàm Python rời ở phần sau.
1. THƯ VIỆN & KHỞI TẠO (PYTHON PANDAS)
Để phân tích kỹ thuật nhanh và chính xác trên tập dữ liệu lớn, sử dụng Class sau:
code
Python
import pandas as pd
import numpy as np
import math

class VNStockAnalyzer:
    def __init__(self, df):
        """
        Input: DataFrame với các cột ['Open', 'High', 'Low', 'Close', 'Volume']
        """
        self.df = df.copy()
        # Chuyển đổi data sang numeric để tránh lỗi
        cols = ['Open', 'High', 'Low', 'Close', 'Volume']
        for c in cols:
            if c in self.df.columns:
                self.df[c] = pd.to_numeric(self.df[c], errors='coerce')

    # --- PHẦN 1.1: MOVING AVERAGES ---
    def add_moving_averages(self):
        """
        SMA = Sum(Price, n) / n
        EMA = Price(t) * k + EMA(y) * (1-k)
        Đặc thù VN: Thêm MA89 (Trung-Dài hạn)
        """
        for p in [10, 20, 50, 89, 200]:
            self.df[f'MA{p}'] = self.df['Close'].rolling(window=p).mean()
            self.df[f'EMA{p}'] = self.df['Close'].ewm(span=p, adjust=False).mean()
        return self.df

    # --- PHẦN 1.2: RSI (RELATIVE STRENGTH INDEX) ---
    def add_rsi(self, period=14):
        """
        RSI = 100 - (100 / (1 + RS))
        RS = Avg Gain / Avg Loss
        """
        delta = self.df['Close'].diff()
        gain = (delta.where(delta > 0, 0)).rolling(window=period).mean()
        loss = (-delta.where(delta < 0, 0)).rolling(window=period).mean()
        
        rs = gain / loss
        self.df['RSI'] = 100 - (100 / (1 + rs))
        return self.df['RSI']

    # --- PHẦN 1.3: MACD ---
    def add_macd(self, fast=12, slow=26, signal=9):
        """
        MACD Line = EMA(12) - EMA(26)
        Signal Line = EMA(9) of MACD
        Histogram = MACD - Signal
        """
        exp1 = self.df['Close'].ewm(span=fast, adjust=False).mean()
        exp2 = self.df['Close'].ewm(span=slow, adjust=False).mean()
        
        self.df['MACD_Line'] = exp1 - exp2
        self.df['Signal_Line'] = self.df['MACD_Line'].ewm(span=signal, adjust=False).mean()
        self.df['MACD_Hist'] = self.df['MACD_Line'] - self.df['Signal_Line']
        return self.df[['MACD_Line', 'Signal_Line', 'MACD_Hist']]

    # --- PHẦN 1.4: BOLLINGER BANDS ---
    def add_bollinger_bands(self, period=20, std_dev=2):
        """
        Upper = SMA(20) + (StdDev * 2)
        Lower = SMA(20) - (StdDev * 2)
        """
        sma = self.df['Close'].rolling(window=period).mean()
        std = self.df['Close'].rolling(window=period).std()
        
        self.df['BB_Upper'] = sma + (std * std_dev)
        self.df['BB_Lower'] = sma - (std * std_dev)
        self.df['BB_Middle'] = sma
        return self.df[['BB_Upper', 'BB_Middle', 'BB_Lower']]

    # --- PHẦN 1.5: ICHIMOKU CLOUD (VN OPTIMIZED) ---
    def add_ichimoku_vn(self):
        """
        Tham số tối ưu cho Midcap VN: 9, 17, 33 (thay vì 9, 26, 52)
        """
        # Tenkan (9)
        high_9 = self.df['High'].rolling(window=9).max()
        low_9 = self.df['Low'].rolling(window=9).min()
        self.df['Tenkan'] = (high_9 + low_9) / 2

        # Kijun (17)
        high_17 = self.df['High'].rolling(window=17).max()
        low_17 = self.df['Low'].rolling(window=17).min()
        self.df['Kijun'] = (high_17 + low_17) / 2
        
        # Span A (Shift 17)
        self.df['SpanA'] = ((self.df['Tenkan'] + self.df['Kijun']) / 2).shift(17)
        
        # Span B (33)
        high_33 = self.df['High'].rolling(window=33).max()
        low_33 = self.df['Low'].rolling(window=33).min()
        self.df['SpanB'] = ((high_33 + low_33) / 2).shift(17)
        
        # Chikou
        self.df['Chikou'] = self.df['Close'].shift(-17)
        return self.df

    # --- PHẦN 1.6: MFI (MONEY FLOW INDEX) ---
    def add_mfi(self, period=14):
        """
        Chỉ báo dòng tiền (RSI + Volume). Quan trọng cho VN30.
        """
        typical_price = (self.df['High'] + self.df['Low'] + self.df['Close']) / 3
        money_flow = typical_price * self.df['Volume']
        
        positive_flow = money_flow.where(typical_price > typical_price.shift(1), 0)
        negative_flow = money_flow.where(typical_price < typical_price.shift(1), 0)
        
        pos_mf_sum = positive_flow.rolling(window=period).mean()
        neg_mf_sum = negative_flow.rolling(window=period).mean()
        
        self.df['MFI'] = 100 - (100 / (1 + (pos_mf_sum / neg_mf_sum.replace(0, 1))))
        return self.df['MFI']
2. CÔNG THỨC FIBONACCI & PIVOT POINTS
2.1 Fibonacci Levels
code
Python
def calculate_fibonacci(swing_high, swing_low, direction='retracement'):
    """
    Tính các mức Fibonacci quan trọng.
    """
    diff = swing_high - swing_low
    levels = {}
    
    if direction == 'retracement': # Từ đáy lên
        levels = {
            '0% (Low)': swing_low,
            '23.6%': swing_low + diff * 0.236,
            '38.2%': swing_low + diff * 0.382,
            '50%': swing_low + diff * 0.5,
            '61.8%': swing_low + diff * 0.618,
            '78.6%': swing_low + diff * 0.786,
            '100% (High)': swing_high
        }
    else: # Extension (Mục tiêu giá)
        levels = {
            '100%': swing_high,
            '161.8%': swing_high + diff * 0.618,
            '261.8%': swing_high + diff * 1.618
        }
    return levels
2.2 Pivot Points (Standard)
code
Python
def calculate_pivot_points(high, low, close):
    """
    P = (H + L + C) / 3
    R1 = 2P - L | S1 = 2P - H
    """
    P = (high + low + close) / 3
    return {
        'Pivot': P,
        'R1': 2*P - low,
        'S1': 2*P - high,
        'R2': P + (high - low),
        'S2': P - (high - low)
    }
3. QUẢN LÝ VỐN & VỊ THẾ (ĐẶC THÙ VN)
3.1 Position Sizing (Risk-Based & Lô 100)
Công thức gốc: Size = (Capital * Risk%) / (Entry - SL)
Điều chỉnh VN: Làm tròn xuống bội số 100.
code
Python
def calculate_position_size_vn(capital, entry, sl, risk_pct=2):
    """
    Tính số lượng cổ phiếu cần mua dựa trên rủi ro.
    - capital: Tổng vốn
    - risk_pct: % rủi ro chấp nhận (thường 1-2%)
    - entry/sl: Giá vào và giá cắt lỗ
    """
    if entry <= sl: return "Error: Entry phải > SL cho lệnh Long"
    
    risk_amt = capital * (risk_pct / 100)
    risk_per_share = entry - sl
    
    raw_shares = risk_amt / risk_per_share
    # Làm tròn xuống lô 100 (Sàn VN)
    shares = int(raw_shares // 100) * 100
    
    total_value = shares * entry
    return {
        'Shares': shares,
        'Total_Value': total_value,
        'Risk_Amount': shares * risk_per_share,
        'Percent_Capital': (total_value / capital) * 100
    }
3.2 Kelly Criterion (Nâng cao)
Dùng để tối ưu hóa tỷ lệ vốn, nhưng nên dùng Half-Kelly để an toàn.
Công thức: Kelly % = W - [(1 - W) / R]
code
Python
def kelly_criterion(win_rate, avg_win, avg_loss):
    """
    win_rate: Tỷ lệ thắng (ví dụ 0.60)
    avg_win/avg_loss: % Lãi TB / % Lỗ TB
    """
    if avg_loss == 0: return 0
    R = avg_win / avg_loss
    kelly = win_rate - ((1 - win_rate) / R)
    
    return {
        'Full_Kelly': max(0, kelly * 100),
        'Half_Kelly': max(0, (kelly / 2) * 100), # Khuyên dùng
        'Quarter_Kelly': max(0, (kelly / 4) * 100)
    }
4. ĐÁNH GIÁ HIỆU SUẤT & RỦI RO
4.1 Risk/Reward & Breakeven
code
Python
def calc_risk_metrics(entry, sl, tp, commission=0.0015):
    """
    Tính R/R và điểm hòa vốn (bao gồm phí 0.15%)
    """
    risk = entry - sl
    reward = tp - entry
    rr_ratio = reward / risk if risk > 0 else 0
    
    # Breakeven = Entry * (1 + fee_mua + fee_ban)
    # Phí ước tính ~0.3% tổng vòng
    breakeven = entry * (1 + (commission * 2))
    
    return {
        'RR_Ratio': round(rr_ratio, 2),
        'Risk_Per_Share': risk,
        'Reward_Per_Share': reward,
        'Breakeven_Price': math.ceil(breakeven)
    }
4.2 Expected Value (EV)
EV = (Win% * Avg_Win) - (Loss% * Avg_Loss)
code
Python
def expected_value(win_rate, avg_win_pct, avg_loss_pct):
    loss_rate = 1 - win_rate
    ev = (win_rate * avg_win_pct) - (loss_rate * avg_loss_pct)
    status = "✅ Khả thi" if ev > 0 else "❌ Thua lỗ dài hạn"
    return {'EV': round(ev, 2), 'Status': status}
4.3 Drawdown & Compound Interest
code
Python
def calculate_drawdown(peak, trough):
    # Mức sụt giảm tài khoản
    return ((trough - peak) / peak) * 100

def compound_interest(principal, rate_monthly, months):
    # Lãi kép: A = P * (1 + r)^n
    return principal * ((1 + rate_monthly/100) ** months)
5. CÔNG CỤ ĐẶC THÙ KHÁC
5.1 Tính Giá Trần/Sàn (Biên độ VN)
Quy tắc làm tròn xuống 100đ (bước giá phổ biến) để đảm bảo đặt lệnh hợp lệ.
code
Python
def get_vn_price_limits(ref_price, exchange='HOSE'):
    """
    exchange: HOSE (7%), HNX (10%), UPCOM (15%)
    """
    margin = 0.07
    if exchange == 'HNX': margin = 0.10
    elif exchange == 'UPCOM': margin = 0.15
    
    delta = ref_price * margin
    
    # Làm tròn xuống hàng trăm
    ceiling = math.floor((ref_price + delta) / 100) * 100
    floor = math.floor((ref_price - delta) / 100) * 100
    
    return {'Ceiling': ceiling, 'Floor': floor, 'Ref': ref_price}
5.2 Hàm Chấm điểm Tự động (Auto Score Link)
Hàm này mô phỏng logic Section 9 trong kb_technical 2025.md để AI có thể tự động chấm điểm sơ bộ trước khi phân tích sâu.
code
Python
def quick_technical_score(price, ma20, ma50, ma89, rsi, macd_hist, vol_ratio):
    score = 0
    # 1. Trend (Max 3đ)
    if price > ma20 > ma50 > ma89: score += 3
    elif price > ma20: score += 1.5
    
    # 2. RSI (Max 2đ)
    if 50 <= rsi <= 70: score += 2
    elif 40 <= rsi < 50: score += 1
    
    # 3. MACD (Max 2đ)
    if macd_hist > 0: score += 2
    
    # 4. Volume (Max 2đ)
    if vol_ratio > 1.2: score += 2
    elif vol_ratio > 1.0: score += 1
    
    # 5. Ichimoku/Pattern (1đ - Placeholder)
    score += 1 
    
    return min(score, 10)
